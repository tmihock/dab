import { OnInit, OnStart } from "@flamework/core";
import { t } from "@rbxts/t";
import { AbstractConstructorRef, ConstructorRef } from "./utility";
/**
 * This enum dictates how component instance guards interact with StreamingEnabled.
 */
export declare enum ComponentStreamingMode {
    /**
     * This disables instance guard streaming, and will only run the instance guard once.
     */
    Disabled = 0,
    /**
     * This will watch for any changes to the instance tree, and rerun the instance guards.
     */
    Watching = 1,
    /**
     * This determines the appropriate streaming mode based on a couple of factors.
     *
     * If on the server, this will always behave like `Disabled`.
     *
     * If on the client, and the attached instance is an `Atomic` model, this will behave like `Disabled`.
     *
     * Otherwise, this behaves like `Watching`.
     */
    Contextual = 2,
    /**
     * This is equivalent to {@link ComponentStreamingMode.Contextual Contextual}.
     */
    Default = 2
}
export interface ComponentConfig {
    /**
     * The CollectionService tag this component is associated with.
     */
    tag?: string;
    /**
     * Override guards for specified attributes.
     */
    attributes?: {
        [key: string]: t.check<unknown>;
    };
    /**
     * By default, Flamework will not construct components which do not pass the specified attribute guards.
     * You can specify default values which Flamework will use instead of cancelling the component's construction.
     */
    defaults?: {
        [key: string]: unknown;
    };
    /**
     * Overrides the guard generated by Flamework to validate instance trees.
     */
    instanceGuard?: t.check<unknown>;
    /**
     * Should this instance be ignored?
     *
     * This property differs from `instanceGuard` because it cancels the CollectionService event,
     * whereas `instanceGuard` may continue to fire, along with other checks.
     */
    predicate?: (instance: Instance) => boolean;
    /**
     * Should this component watch for changes to attributes?
     *
     * This will disable `onAttributeChanged` events in the component, as well.
     */
    refreshAttributes?: boolean;
    /**
     * Specifies where components can be constructed via CollectionService.
     * This has higher priority than `ancestorBlacklist`, including the default blacklist.
     *
     * This has the same behavior as a predicate.
     */
    ancestorWhitelist?: Instance[];
    /**
     * Specifies where components can not be constructed via CollectionService.
     * Defaults to ServerStorage and ReplicatedStorage.
     *
     * This has the same behavior as a predicate.
     */
    ancestorBlacklist?: Instance[];
    /**
     * Flamework will warn whenever a component isn't able to be created while watching for CollectionService tags,
     * this allows you to adjust how long until that warning appears.
     *
     * Defaults to 5, set to 0 to disable.
     */
    warningTimeout?: number;
    /**
     * Override the component streaming mode, defaults to `Contextual`.
     */
    streamingMode?: ComponentStreamingMode;
}
/**
 * Register a class as a Component.
 *
 * @metadata flamework:implements flamework:parameters injectable intrinsic-component-decorator
 */
export declare const Component: ((opts?: ComponentConfig | undefined) => ((ctor: defined) => never) & {
    _flamework_Decorator: never;
}) & {
    _flamework_Parameters: [opts?: ComponentConfig | undefined];
};
/**
 * This class is responsible for loading and managing
 * all components in the game.
 */
export declare class Components implements OnInit, OnStart {
    private components;
    private classParentCache;
    private activeComponents;
    private activeInheritedComponents;
    private reverseComponentsMapping;
    private componentConstructing;
    private trackers;
    private componentWaiters;
    private componentCleanup;
    private componentAddedListeners;
    private componentRemovedListeners;
    onInit(): void;
    onStart(): void;
    private getComponentTracker;
    private getOrderedParents;
    private getAttributeGuards;
    private getAttributes;
    private getConfigValue;
    private setupComponent;
    private addIdMapping;
    private removeIdMapping;
    private canCreateComponentEager;
    private getDependencyResolutionOptions;
    private getPolymorphicIds;
    /**
     * This returns the specified component associated with the instance.
     *
     * The specified type must be exact and not a lifecycle event or superclass. If you want to
     * query for lifecycle events or superclasses, you should use the `getComponents` method.
     *
     * @metadata macro
     */
    getComponent<T extends object>(instance: Instance, componentSpecifier?: ConstructorRef<T>): T | undefined;
    /**
     * This returns all components associated with the instance that extend or implement the specified type.
     *
     * For example, `getComponents<OnTick>` will retrieve all components that subscribe to the OnTick lifecycle event.
     *
     * @metadata macro
     */
    getComponents<T extends object>(instance: Instance, componentSpecifier?: AbstractConstructorRef<T>): T[];
    /**
     * Adds the specified component to the instance.
     * The specified class must be exact and cannot be a lifecycle event or superclass.
     *
     * @metadata macro
     */
    addComponent<T>(instance: Instance, componentSpecifier?: ConstructorRef<T>): T;
    /**
     * Removes the specified component from this instance.
     * The specified class must be exact and cannot be a lifecycle event or superclass.
     *
     * @metadata macro
     */
    removeComponent<T extends object>(instance: Instance, componentSpecifier?: ConstructorRef<T>): void;
    /**
     * This returns all components, across all instances, which extend or implement the specified type.
     *
     * For example, `getAllComponents<OnTick>` will retrieve all components that subscribe to the OnTick lifecycle event.
     *
     * @metadata macro
     */
    getAllComponents<T extends object>(componentSpecifier?: AbstractConstructorRef<T>): T[];
    /**
     * This returns a promise which will fire when the specified component is added.
     * This will first call `getComponent` which means it can resolve instantly and will also
     * have the eager loading capabilities of `getComponent`.
     *
     * This only fires once and should be cancelled to avoid memory leaks if the Promise is discarded prior to being invoked.
     *
     * @metadata macro
     */
    waitForComponent<T extends object>(instance: Instance, componentSpecifier?: ConstructorRef<T>): Promise<T>;
    /**
     * This function listens for the specified component type to be added to any instance.
     *
     * This function also supports polymorphism, which means you can listen for specific interfaces or superclasses.
     *
     * @metadata macro
     */
    onComponentAdded<T extends object>(callback: (value: T, instance: Instance) => void, componentSpecifier?: AbstractConstructorRef<T>): RBXScriptConnection;
    /**
     * This function listens for the specified component type to be removed from any instance.
     * The callback is invoked before the component's `destroy` method is called.
     *
     * This function also supports polymorphism, which means you can listen for specific interfaces or superclasses.
     *
     * @metadata macro
     */
    onComponentRemoved<T extends object>(callback: (value: T, instance: Instance) => void, componentSpecifier?: AbstractConstructorRef<T>): RBXScriptConnection;
}
