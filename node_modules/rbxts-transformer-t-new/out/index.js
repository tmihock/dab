"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = __importStar(require("typescript"));
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var utility = __importStar(require("./utility"));
var transformerUtil = __importStar(require("./transformer"));
var transformer_1 = require("./transformer");
var didReplaceImport = false;
function transformer(program) {
    return function (context) { return function (file) {
        var replaceIndexNode = function (file) {
            var replacer = utility.getNodeReplacer(transformerUtil.is_t_ImportDeclaration(program), typescript_1.factory.createEmptyStatement());
            return typescript_1.default.visitEachChild(file, function (node) {
                var _a = __read(replacer(node, program), 2), replacement = _a[0], didReplace = _a[1];
                didReplaceImport = didReplace;
                return replacement;
            }, context);
        };
        return visitNodeAndChildren(replaceIndexNode(file), program, context);
    }; };
}
exports.default = transformer;
function visitNodeAndChildren(node, program, context) {
    return typescript_1.default.visitEachChild(visitNode(node, program), function (childNode) { return visitNodeAndChildren(childNode, program, context); }, context);
}
function visitNode(node, program) {
    if (isModuleImportExpression(node, program))
        if (didReplaceImport)
            return node; // factory.createEmptyStatement()
        else
            return [
                typescript_1.factory.createImportDeclaration(undefined, typescript_1.factory.createImportClause(false, undefined, typescript_1.factory.createNamedImports([
                    typescript_1.factory.createImportSpecifier(false, undefined, typescript_1.factory.createIdentifier(transformerUtil.OBJECT_NAME))
                ])), typescript_1.factory.createStringLiteral("@rbxts/t")),
                node
            ];
    if (typescript_1.default.isCallExpression(node))
        return visitCallExpression(node, program);
    return node;
}
function handleTerrifyCallExpression(node, functionName, typeChecker) {
    switch (functionName) {
        case transformerUtil.MARCO_NAME: {
            var typeArguments = node.typeArguments;
            if (typeArguments === undefined || typeArguments.length === 0)
                throw new Error("Please pass a type argument to the $terrify function");
            var type = typeChecker.getTypeFromTypeNode(typeArguments[0]);
            return (0, transformer_1.buildType)(type, typeChecker);
        }
        default:
            throw "function ".concat(functionName, " cannot be handled by this version of rbxts-interface-to-t");
    }
}
function visitCallExpression(node, program) {
    var typeChecker = program.getTypeChecker();
    var signature = typeChecker.getResolvedSignature(node);
    if (!signature)
        return node;
    var declaration = signature.declaration;
    if (!declaration || typescript_1.default.isJSDocSignature(declaration) || !isModule(declaration.getSourceFile()))
        return node;
    var functionName = declaration.name && declaration.name.getText();
    if (!functionName)
        return node;
    return handleTerrifyCallExpression(node, functionName, typeChecker);
}
var sourceText = fs_1.default.readFileSync(path_1.default.join(__dirname, "..", "index.d.ts"), "utf8");
function isModule(sourceFile) {
    return sourceFile.text === sourceText;
}
function isModuleImportExpression(node, program) {
    if (!typescript_1.default.isImportDeclaration(node))
        return false;
    if (!node.importClause)
        return false;
    var namedBindings = node.importClause.namedBindings;
    if (!node.importClause.name && !namedBindings)
        return false;
    var importSymbol = program.getTypeChecker().getSymbolAtLocation(node.moduleSpecifier);
    if (!importSymbol || !isModule(importSymbol.valueDeclaration.getSourceFile())) // TODO
        return false;
    return true;
}
