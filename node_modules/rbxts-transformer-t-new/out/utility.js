"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeObjects = exports.getTypeId = exports.isSymbolOf = exports.getAliasedSymbolOfNode = exports.getAliasedSymbol = exports.getNodeReplacer = exports.buildPropertyName = exports.extractProperty = exports.isCustomEnum = exports.isLiteral = exports.isOptionalPropertyDeclaration = exports.isObjectType = exports.isBrickColorType = exports.isMapType = exports.isArrayType = exports.isTupleType = exports.isFunctionType = exports.isEnum = exports.separateArray = exports.mergeArrays = void 0;
var typescript_1 = __importDefault(require("typescript"));
var path_1 = __importDefault(require("path"));
/**
 * Concatenates two arrays and removes duplicates
 */
function mergeArrays(array1, array2) {
    return __spreadArray([], __read(new Set(__spreadArray(__spreadArray([], __read(array1), false), __read(array2), false))), false);
}
exports.mergeArrays = mergeArrays;
/**
 * Separates an array into two arrays:
 * the first array contains elements matched
 * by predicate as true, the second as false.
 */
function separateArray(array, predicate) {
    var nextIteration = function (array, onTrue, onFalse) {
        if (array.length === 0)
            return [onTrue, onFalse];
        var _a = __read(array), head = _a[0], tail = _a.slice(1);
        if (predicate(head))
            return nextIteration(tail, __spreadArray(__spreadArray([], __read(onTrue), false), [head], false), onFalse);
        return nextIteration(tail, onTrue, __spreadArray(__spreadArray([], __read(onFalse), false), [head], false));
    };
    return nextIteration(array, [], []);
}
exports.separateArray = separateArray;
/**
 * Checks if type is an EnumItem
 */
function isEnum(type) {
    var _a, _b;
    return ((_b = (_a = type.aliasSymbol) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.escapedName) === "Enum";
}
exports.isEnum = isEnum;
/**
 * Checks if ts.Type is a function
 */
function isFunctionType(type) {
    return type.getCallSignatures().length !== 0;
}
exports.isFunctionType = isFunctionType;
/**
 * Checks if ts.Type is of ts.TupleType
 */
function isTupleType(type, typeChecker) {
    return typeChecker.isTupleType(type);
}
exports.isTupleType = isTupleType;
/**
 * Checks if ts.Type is of Array type
 */
function isArrayType(type, typeChecker) {
    return typeChecker.isArrayType(type);
}
exports.isArrayType = isArrayType;
/**
 * Checks if ts.Type is of Map type
 */
function isMapType(type) {
    var _a;
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.getName()) === "Map";
}
exports.isMapType = isMapType;
/**
 * Checks if ts.Type is of Map type
 */
function isBrickColorType(type) {
    var _a;
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.getName()) === "BrickColor";
}
exports.isBrickColorType = isBrickColorType;
/**
 * Converts array of ts.Types to array of ts.Expressions
 */
/**
 * Checks if ts.Type being is of ts.ObjectType
 */
function isObjectType(type) {
    var _a;
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.getName()) === "__type";
}
exports.isObjectType = isObjectType;
/**
 * Checks if property declaration matched is optional
 */
function isOptionalPropertyDeclaration(prop) {
    var property = prop.valueDeclaration;
    return property.questionToken !== undefined;
}
exports.isOptionalPropertyDeclaration = isOptionalPropertyDeclaration;
/**
 * Checks if type is a literal
 */
function isLiteral(typeChecker) {
    return function (type) { return type.isLiteral() || ["true", "false"].includes(typeChecker.typeToString(type)); };
}
exports.isLiteral = isLiteral;
function isCustomEnum(type) {
    var _a, _b;
    return ((_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.valueDeclaration) === null || _b === void 0 ? void 0 : _b.kind) === typescript_1.default.SyntaxKind.EnumDeclaration;
}
exports.isCustomEnum = isCustomEnum;
/**
 * Extracts property type and name from ts.Symbol
 */
function extractProperty(prop, typeChecker) {
    var _a;
    var declaration = prop.valueDeclaration;
    var type = prop.type === undefined
        ? typeChecker.getTypeFromTypeNode(declaration.type)
        : (_a = prop.type.target) !== null && _a !== void 0 ? _a : prop.type;
    var name = String(prop.escapedName);
    return { name: name, type: type };
}
exports.extractProperty = extractProperty;
/**
 * Builds name for property.
 * If it is simple, use just string.
 * For complex names wrap it into ts.StringLiteral
 */
function buildPropertyName(name) {
    if (name.match(/^[a-zA-Z_]+[\w_]+$/) !== null)
        return name;
    return typescript_1.default.factory.createStringLiteral(name);
}
exports.buildPropertyName = buildPropertyName;
/**
 * Returns mapping function that replaces
 * nodes that satisfy the passed predicate
 * with a replacement node passed but skips the first appearance
 */
function getNodeReplacer(predicate, replacement) {
    var replaced = false;
    return function (node) {
        if (replaced && predicate(node))
            return [replacement, replaced];
        if (replaced || !predicate(node))
            return [node, replaced];
        replaced = true;
        return [node, replaced];
    };
}
exports.getNodeReplacer = getNodeReplacer;
/**
 * Returns aliased symbol of ts.Symbol or
 * this symbol itself if it is aliased
 */
function getAliasedSymbol(symbol, typeChecker) {
    try {
        return typeChecker.getAliasedSymbol(symbol);
    }
    catch (_) {
        return symbol;
    }
}
exports.getAliasedSymbol = getAliasedSymbol;
/**
 * Returns aliased symbol of ts.Identifier
 */
function getAliasedSymbolOfNode(node, typeChecker) {
    var symbol = typeChecker.getSymbolAtLocation(node);
    if (symbol === undefined)
        return undefined;
    return getAliasedSymbol(symbol, typeChecker);
}
exports.getAliasedSymbolOfNode = getAliasedSymbolOfNode;
/**
 * Checks is symbol belongs to declaration
 * with name "name" located in file filePath
 */
function isSymbolOf(symbol, name, filePath) {
    if (symbol.escapedName !== name)
        return false;
    return __spreadArray([symbol.valueDeclaration], __read(symbol.declarations), false).filter(Boolean) // TODO
        .some(function (declaration) { return path_1.default.join(declaration.getSourceFile().fileName) === filePath; });
}
exports.isSymbolOf = isSymbolOf;
/**
 * Returns id of ts.Type
 */
function getTypeId(type) {
    return type.id;
}
exports.getTypeId = getTypeId;
/**
 * Merges two objects
 */
function mergeObjects(obj1, obj2) {
    return __assign(__assign({}, obj1), obj2);
}
exports.mergeObjects = mergeObjects;
